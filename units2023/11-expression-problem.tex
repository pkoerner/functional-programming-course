\documentclass[11pt,a4paper]{article}
\input{header.tex}
\setcounter{numb}{11}


\begin{document}

\begin{minipage}[b]{\textwidth}
	\parbox[t]{5cm}{%
		\includegraphics[width=4cm]{unilogo}
		\hfill
	}
	\parbox[b]{11cm}{%
		%\scshape%
		Heinrich-Heine-University D\"usseldorf\\
		Computer Science Department\\
		Software Engineering and Programming Languages\\
		%Professor Dr.\ M.\ Leuschel
		Philipp K\"orner
	}
\end{minipage}
\begin{center}
	\bf
	Functional Programming -- WT 2023 / 2024\\
	Reading Guide 11: The Expression Problem
\end{center}

\pagestyle{empty}

\paragraph{Timeline:} This unit should be completed by 08.01.2024.

\paragraph{Note:} This unit is way smaller than usual. Happy holidays and enjoy your time off!
We will return to the epochal time model for the last two implementations
before we will consider solutions to the expression problem in Clojure.

\section{Material} 

\begin{itemize}
%\item Clojure for the Brave and True, chapter 13
%\item Clojure Reference: Multimethods \url{https://clojure.org/reference/multimethods}
%\item Clojure Reference: Protocols \url{https://clojure.org/reference/protocols}
\item Philip Wadler: The Expression Problem \url{http://homepages.inf.ed.ac.uk/wadler/papers/expression/expression.txt}
\item Slides: vl-10.pdf 
\end{itemize}


\section{Learning Outcomes}

After completing this unit you should be able to

\begin{itemize}
    \item describe the expression problem.
    \item identify use cases as well as advantages and disadvantages of wrappers and monkey patching.
    %\item explain how multimethods and protocols solve the expression problem.
    %\item use multimethods and protocols.
    %\item compare the expressiveness of multimethods and protocols.
    %\item recall and compare the performance of multimethods and protocols.
\end{itemize}

\section{Highlights}

\begin{itemize}
    \item Expression problem
    %\item Multimethods
    %\item Protocols
    %\item Functions / Macros: \verb|defmulti|, \verb|defmethod|, \verb|defprotocol|, \verb|extend-protocol|, \verb|extend-type|, \verb|extend|
\end{itemize}



\section{Exercises}

No practical exercises here.
Proceed with the usual 4clojure exercises
only if you find the time.


%\begin{exercise}[Lazy Searching - 4clojure Nr. 108]
%
%Implement a function that receives any number of ascending sequences
%as input and returns the smallest element that occurs in all sequences.
%The inputs can be infinite sequences.
%
%\begin{verbatim}
%(common-min [3 4 5])
%=> 3
%(common-min [1 2 3 4 5 6 7] [0.5 3/2 4 19])
%=> 4
%(common-min (range) (range 0 100 7/6) [2 3 5 7 11 13])
%=> 7
%(common-min (map (fn [x] (* x x x)) (range)) ;; Cubic numbers
%            (filter (fn [x] (zero? (bit-and x (dec x)))) (range)) ;; Powers of two
%            (iterate inc 20)) ;; Numbers greater than/equal to 20
%=> 64
%\end{verbatim}

%\end{exercise}

	\section*{Questions}
	If you have any questions, please contact Philipp K"orner (\texttt{p.koerner@hhu.de}) or post it to the Rocket.Chat group.
\end{document}

