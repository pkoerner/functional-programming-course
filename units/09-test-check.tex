\documentclass[11pt,a4paper]{article}

\usepackage[ngerman]{babel}
\usepackage[TS1,T1]{fontenc}
\usepackage[utf8x]{inputenc}
\usepackage{theorem}
\usepackage[scaled=0.9]{helvet}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[T1]{fontenc}
\usepackage{hyperref}
\usepackage{stmaryrd}
\usepackage{pgf,tikz}
\usepackage{relsize}
\usepackage{enumitem}
\usepackage{graphicx}
\usepackage{csquotes}
\usepackage{algpseudocode,amsmath,xifthen}

\newcounter{numb}
\theoremstyle{break}
\theorembodyfont{\upshape}
   	\newtheorem{aufgabe}{Aufgabe}[numb]
\setcounter{numb}{9}
\setlength{\oddsidemargin}{0cm}
\setlength{\textwidth}{16cm}
\setlength{\textheight}{23cm}
\setlength{\topmargin}{-2cm}

\usetikzlibrary{shapes,arrows,automata,positioning,decorations.fractals}
\renewcommand\familydefault{\sfdefault}


\begin{document}

\begin{minipage}[b]{\textwidth}
\parbox[t]{5cm}{%
\includegraphics[width=4cm]{unilogo}
\hfill
}
\parbox[b]{11cm}{%
%\scshape%
Heinrich-Heine-Universit\"at D\"usseldorf\\
Institut f\"ur Informatik\\
Lehrstuhl Softwaretechnik und Programmiersprachen\\
%Professor Dr.\ M.\ Leuschel
Philipp K\"orner
}

%%date
%\hfill 1.\@ August 2017\rule{0mm}{6mm}\quad\ %% <--
\end{minipage}
\begin{center}
\bf
Funktionale Programmierung -- WS 2020 / 2021\\
Reading Guide 10: Generatives Testing
\end{center}

\pagestyle{empty}

\paragraph{Zeitliche Orientierung:} Diese Lerneinheit sollte bis zum 28.01.2021 abgeschlossen werden.
%\paragraph{Abgabe des Lerntagebuchs} \"uber das ILIAS bis zum 16.5.2020 mit unbegrenzt Material, Nachfrist bis zum 23.5.2020 mit zwei Seiten A4.

\section{Material} 

\begin{itemize}
    \item Getting Clojure, Kapitel 14
\item 21\_transients.clj
\item 22\_ebt.clj
\item 15\_test\_check.clj
\item Reid Draper: Powerful Testing with test.check \url{https://www.youtube.com/watch?v=JMhNINPo__g}
\item Gary Fredericks: Building test.check Generators \url{https://www.youtube.com/watch?v=F4VZPxLZUdA}
\item John Hughes: Testing the Hard Stuff and Staying Sane \url{https://www.youtube.com/watch?v=zi0rHwfiX1Q}
\end{itemize}


\section{Lernziele}

Nach dem Bearbeiten dieser Lerneinheit sollten Sie in der Lage sein

\begin{itemize}
    \item Transients korrekt zu verwenden.
    \item example-based Tests in Clojure zu schreiben.
    \item generative Tests in Clojure zu schreiben.
    \item Vor- und Nachteile von example-based und generativen Tests zu diskutieren.
\end{itemize}

\section{Highlights}

\begin{itemize}
    \item Transients: \verb|transient|, \verb|persistent!|, \verb|conj!|, \verb|disj!|, \verb|assoc!|, \verb|dissoc!|, \verb|disj!|
    \item Testing: \verb|deftest|, \verb|is|, \verb|are|
    \item test.check: Generator-Namespace, \verb|for-all|, \verb|quick-check|
\end{itemize}



\section{Aufgaben}

\begin{aufgabe}[\texttt{test.check}]

In den Dateien zur \"Ubung finden Sie den Namespace \verb|blatt9.edit-distance|.
Betrachten Sie dort die Funktionen \verb|levenshtein| und \verb|levenschtein|.

\begin{enumerate}[label=\alph*)]
    \item Erzeugen Sie einen Namespace im test-Verzeichnis,
        der auf die beiden Funktionen zugreifen kann.

    \item Schreiben Sie eine \verb|test.check| Property,
        die fehlschl\"agt, wenn zwei nicht-leere
        Strings als Eingabe unterschiedliche Ergebnisse bei den beiden Funktionen liefern.
        Welche Implementierung ist falsch?
        Was ist der Fehler? 
        
        Anmerkung: Sie m\"ussen die fehlerhafte Implementierung nicht reparieren.

    \item 
        Schreiben Sie einen Generator \verb|user-generator|, der Benutzer an der Uni generiert.
        Ein Benutzer wird durch eine Map repr\"asentiert,
        die Vor- und Nachname sowie eine Kennung enth\"alt.
        Die Kennung besteht aus den ersten zwei Zeichen des Vornamens
        und den ersten drei Zeichen des Nachnamens und drei Ziffern.
        Ein Beispiel f\"ur einen Benutzer, der generiert wird, ist
        
        \verb|{:vorname "John", :nachname "Wayne", :kennung "joway142"}|.

        Ist ein Name nicht lang genug, werden in der Kennung so viele Zeichen wie m\"oglich verwendet, zum Beispiel
        ist die Kennung von \enquote{Mr. X} dann \verb|mrx666|.
        

		Sie k\"onnen aus einer festen Menge an Namen ausw\"ahlen.
        Dazu k\"onnen Sie zum Beispiel die Namenslisten aus
        \url{https://github.com/dominictarr/random-name} verwenden.
\end{enumerate}
\end{aufgabe}

\begin{aufgabe}[Teure Wege]
Gegeben soll ein Dreieck in Form eines Vektors von Vektoren. Es soll ein m"oglichst billiger Pfad von der Spitze des Dreiecks zum Boden gesucht werden. Es darf in jedem Schritt nur ein adjazentes Folgefeld in der n"achst tieferliegenden Reihe gew"ahlt werden

\enlargethispage{2\baselineskip}
\begin{verbatim}
user=> (path [   [1]
                [2 4]
               [5 1 4]
              [2 3 4 5]])
7 ;; 1 + 2 + 1 + 3
user=> (path [    [3]
                 [2 4]
                [1 9 3]
               [9 9 2 4]
              [4 6 6 7 8]
             [5 7 3 5 1 4]])
20 ;; ; 3 + 4 + 3 + 2 + 7 + 1

\end{verbatim}
\end{aufgabe}

\begin{aufgabe}[Trampoline (4clojure Nr. 78) und Rekursion]
Wir haben bereits gesehen, dass bei Selbstrekursion in Tail-Position
der Einsatz von \verb|recur| daf\"ur sorgt, dass keine zus\"atzlichen Stackframes
pro Rekursionsschritt aufgebaut werden.
Dieser Ansatz funktioniert nicht, wenn zwei (oder mehr) Funktionen sich gegenseitig
aufrufen sollen.

Die Higher-Order Function \verb|trampoline| nimmt eine Funktion
und beliebig viele Werte entgegen.
Diese Funktion wird dann mit den Werten als Parameter aufgerufen.
Ist die R\"uckgabe selbst wieder eine Funktion, wird diese ohne Parameter aufgerufen.
Solange die so resultierenden R\"uckgaben Funktionen sind, werden diese weiter aufgerufen,
ansonsten wird die R\"uckgabe von \verb|trampoline| zur\"uckgegeben.

\begin{enumerate}[label=\alph*)]
    \item
Implementieren Sie eine Funktion, die sich wie \verb|trampoline| verh\"alt.
Insbesondere soll die Rekursion keine weiteren Stackframes aufbauen.

\begin{verbatim}
(letfn [(triple [x] (fn [] (sub-two (* 3 x))))
        (sub-two [x] (fn [] (stop? (- x 2))))
        (stop? [x] (if (> x 50) x (fn [] (triple x))))]
  (my-trampoline triple 2))
=> 82

(letfn [(my-even? [x] (if (zero? x) true (fn [] (my-odd? (dec x)))))
        (my-odd? [x] (if (zero? x) false (fn [] (my-even? (dec x)))))]
  (map (partial my-trampoline my-even?) (range 6)))
=> [true false true false true false]
\end{verbatim}

Hinweis:
Mit \verb|fn?| kann man \"uberpr\"ufen, ob ein Wert eine Funktion ist oder nicht.

Anmerkung: \verb|partial| ist eine Funktion h\"oherer Ordnung,
die eine Funktion \verb|f| und einen Teil der Argumente $a_1$, \dots, $a_i$
entgegennimmt, und eine Funktion zur\"uckgibt, die weitere Parameter $a_{i+1}, \dots, a_n$ ($i \leq n$) nimmt
und \verb|f| mit $a_1$ bis $a_n$ aufruft.
\verb|letfn| ist ein besonderes \verb|let| f\"ur Funktionen.

\item Was muss man machen, wenn das Ergebnis der gesamten Berechnung selbst eine Funktion sein soll?
\end{enumerate}

\end{aufgabe}

\section*{Fragen}
Bei Fragen wenden Sie sich bitte an Philipp K"orner (\texttt{p.koerner@hhu.de}).
\end{document}

