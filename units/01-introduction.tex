\documentclass[11pt,a4paper]{article}
\input{header.tex}
\setcounter{numb}{1}


\begin{document}

\begin{minipage}[b]{\textwidth}
	\parbox[t]{5cm}{%
		\includegraphics[width=4cm]{unilogo}
		\hfill
	}
	\parbox[b]{11cm}{%
		%\scshape%
		Heinrich-Heine-University D\"usseldorf\\
		Computer Science Department\\
		Software Engineering and Programming Languages\\
		%Professor Dr.\ M.\ Leuschel
		Philipp K\"orner
	}
\end{minipage}
\begin{center}
	\bf
	Functional Programming -- WISE 2020 / 2021\\
	Reading Guide 1: Introduction and syntax
\end{center}

\pagestyle{empty}

\section{Material} 

\begin{itemize}
\item Clojure for the Brave and True, chapter 3
\item 01\_intro.clj
\item 07\_java\_interop.clj
\item 08\_namespaces.clj
\item Rich Hickey: Clojure for Java Programmers \url{https://www.youtube.com/watch?v=P76Vbsk_3J0} (until 1:35:38)
%\item Rich Hickey: Clojure for Java Programmers Part 2 \url{https://www.youtube.com/watch?v=hb3rurFxrZ8} (Overview over further topics of the lecture)
\end{itemize}

\paragraph{Deadline:} This unit should be completed by 12.11.2020.

\section{Learning Objectives}

After finishing this unit you should be able to

\begin{itemize}
	\item determine the evaluation order of elements in a function call.
    \item define functions with local bindings.
    \item use the fundamental control structures in small functions.
    \item use built-in higher-order functions.
    \item write higher-order functions.
    \item recall fundamental sequence operations provided by the standard library.
\end{itemize}

\section{Highlights}

\begin{itemize}
    \item $\beta$-reduction as evaluation-mechanism
    \item Lists and sequences
    \item Higher-Order functions: concept, \verb|map|, \verb|filter|, \verb|reduce|, \verb|apply|
    \item Special forms: \verb|def|, \verb|fn|, \verb|if|, \verb|let|, \verb|do|
    \item Sequence operations: \verb|first|, \verb|rest|, \verb|range|, \verb|cons|, \verb|conj|, \verb|assoc|, \verb|dissoc|, \verb|disj|
    \item Macros: \verb|ns|, \verb|for|, \verb|cond|, \verb|and|, \verb|or|
\end{itemize}



\section{Exercises}

\paragraph{Notes}
Solving the exercises is voluntary.
Admission to the exam is solely based on passing the tests in the ILIAS.
Since programming is required in the exam
it is highly recommended to work on the exercises.

In the ILIAS you can find templates for leiningen projects under Lerneinheiten > projektskelette.zip.
Included there you will find functionality tests, which you can execute with \verb|lein test|\footnote{The Plug-in \url{https://github.com/weavejester/lein-auto} is useful in combination with this.}.

You can initially define symbols with \verb|(declare seq-e fibonacci remove-duplicates)|
to get rid of exceptions which are caused by the tests trying to reference undefined global variables and functions.
Alternatively you can execute tests individually (see \verb|lein help test|).

\begin{exercise}[Sequences]

In the following exercise simply define the described sequences. As Example: If you are to define the sequence of numbers between -100 and 100, a valid solution is: \texttt{(def example-seq (range -100 101))}
  

\begin{enumerate}[label=\alph*)]
  \item Define the sequence \verb|seq-a|, containing all integers from 100 to -100 in descending order.
% \item Define the sequence containing all even numbers from 0 to 1000.
  \item Define the sequence \verb|seq-b|, containing all square integers between 0 and 1000.
  \item Define the sequence \verb|seq-c|, containing all integers between 0 and 1000, which are not evenly divisible by 3.
  \item Define the sequence \verb|seq-d|, containing all tuples [n, m] of integers for which the following holds: $0 < n < 1000 \wedge n^2 < m \wedge \text{m is minimal}$.  The sequence begins with tuples [1,2], [2,5], [3,10].
  \item Define the sequence \verb|seq-e|, containing all integers with 5 digits (represented as 5 tuple), which are palindromes. Additionally the digits should be strictly ascending up to the middle digit. [0 2 3 2 0] is part of the sequence, but [0 3 2 3 0] is not, neither is [1 1 1 1 1].
%  (defn palin []
%  (for [a (range 0 10) b (range 0 10) c (range 0 10) :when (< a b c)]
%    [a b c b a]))
  
    
  \end{enumerate}
\end{exercise}

\begin{exercise}[Fibonacci]
The Fibonacci sequence begins with $F_0=0$ and $F_1=1$. Every subsequent number is the sum of the two preceding ones: $F_{n}=F_{n-1}+F_{n-2}$ 
\begin{enumerate}[label=\alph*)]
  \item Define a function \verb|fibonacci|, which takes an integer $z$ as input and generates the first $z$ Fibbonacci numbers.
  \item Test your function with an input of 100.
  \end{enumerate}
\end{exercise}






\begin{exercise}[Removing duplicates]
Given a vector $v$, which can contain duplicate elements, write a function \texttt{remove-duplicates} that removes all duplicates from the vector, maintaining the original order of the elements.

Following are some example calls of this function:
\begin{verbatim}
user=> (remove-duplicates [])
()
user=> (remove-duplicates nil)
()
user=> (remove-duplicates [1 2 1])
(1 2)
user=> (remove-duplicates [1 2 3 "dd" 2 :a 3])
(1 2 3 "dd" :a)
\end{verbatim}

It is only important that the result is a sequential collection. The specific data structure is irrelevant.
\end{exercise}


\section*{Questions}
If you have any questions, please contact Philipp K"orner (\texttt{p.koerner@hhu.de}).
\end{document}

