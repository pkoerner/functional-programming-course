\documentclass[11pt,a4paper]{article}
\input{header.tex}
\setcounter{numb}{1}


\begin{document}

\begin{minipage}[b]{\textwidth}
	\parbox[t]{5cm}{%
		\includegraphics[width=4cm]{unilogo}
		\hfill
	}
	\parbox[b]{11cm}{%
		%\scshape%
		Heinrich-Heine-University D\"usseldorf\\
		Computer Science Department\\
		Software Engineering and Programming Languages\\
		%Professor Dr.\ M.\ Leuschel
		Philipp K\"orner
	}
\end{minipage}
\begin{center}
\bf
Funktionale Programmierung -- WS 2020 / 2021\\
Reading Guide 1: Einf\"uhrung und Syntax
\end{center}

\pagestyle{empty}

%\paragraph{Abgabe des Lerntagebuchs} \"uber das ILIAS bis zum 16.5.2020 mit unbegrenzt Material, Nachfrist bis zum 23.5.2020 mit zwei Seiten A4.

\section{Material} 

\begin{itemize}
\item Clojure for the Brave and True, Kapitel 3
\item 01\_intro.clj
\item 07\_java\_interop.clj
\item 08\_namespaces.clj
\item Rich Hickey: Clojure for Java Programmers \url{https://www.youtube.com/watch?v=P76Vbsk_3J0} (bis 1:35:38)
%\item Rich Hickey: Clojure for Java Programmers Part 2 \url{https://www.youtube.com/watch?v=hb3rurFxrZ8} (Übersicht über weitere Themen der Veranstaltung)
\end{itemize}

\paragraph{Zeitliche Orientierung:} Diese Lerneinheit sollte bis zum 12.11.2020 abgeschlossen werden.

\section{Lernziele}

Nach dem Bearbeiten dieser Lerneinheit sollten Sie in der Lage sein

\begin{itemize}
    \item die Reihenfolge von Aufrufen bei der Funktionsauswertung zu bestimmen.
    \item selbst Funktionen mit lokalen Bindings zu definieren.
    \item die grunds\"atzlichen Kontrollstrukturen in einfachen Funktionen zu verwenden.
    \item eingebaute higher-order functions zu verwenden.
    \item selbst higher-order functions zu schreiben.
    \item grundlegende Sequenzoperationen aus der Standardbibliothek kennen.
\end{itemize}

\section{Highlights}

\begin{itemize}
    \item $\beta$-Reduktion als Auswertungsmechanismus
    \item Listen und Sequenzen
    \item Higher-Order Funktionen: Konzept, \verb|map|, \verb|filter|, \verb|reduce|, \verb|apply|
    \item Special Forms: \verb|def|, \verb|fn|, \verb|if|, \verb|let|, \verb|do|
    \item Sequenzoperationen: \verb|first|, \verb|rest|, \verb|range|, \verb|cons|, \verb|conj|, \verb|assoc|, \verb|dissoc|, \verb|disj|
    \item Macros: \verb|ns|, \verb|for|, \verb|cond|, \verb|and|, \verb|or|
\end{itemize}



\section{Aufgaben}

\paragraph{Anmerkungen}
Die Bearbeitung der Aufgaben ist freiwillig.
F\"ur die Klausurzulassung sind ausschlie\ss{}lich die Tests im ILIAS relevant.
Da in der Klausur aber auch programmiert werden muss,
empfehle ich sehr, dass Sie sich mit den Programmieraufgaben auseinandersetzen.

Im ILIAS finden Sie unter Lerneinheiten > projektskelette.zip Vorlagen f\"ur die Leiningen Projekte.
Dort enthalten sind auch Tests der Funktionalit\"at, die Sie mit \verb|lein test| ausf\"uhren k\"onnen\footnote{In Kombination ist das Plug-in \url{https://github.com/weavejester/lein-auto} n\"utzlich.}.

Sie k\"onnen die Symbole zun\"achst mit \verb|(declare seq-e fibonacci remove-duplicates)| definieren,
um Exceptions loszuwerden, die darauf zur\"uckzuf\"uhren sind, dass die globalen Variablen oder Funktionen noch nicht definiert sind.
Alternativ k\"onnen Sie auch einzelne Tests ausf\"uhren (vgl. \verb|lein help test|).

\begin{exercise}[Sequenzen]

In dieser Aufgabe sollen Sie einfache Sequenzen erzeugen. Ein Beispiel: Wenn die Aufgabe ist die Sequenz zu definieren, die die Zahlen zwischen -100 und 100 beinhaltet, k\"onnte Ihre L\"osung so aussehen: \texttt{(def beispiel-seq (range -100 101))}
  

\begin{enumerate}[label=\alph*)]
  \item Definieren Sie die Sequenz \verb|seq-a|, die alle ganzen Zahlen von 100 bis -100 in absteigender Reihenfolge beinhaltet.
%  \item Definieren Sie die Sequenz, die alle geraden Zahlen von 0 bis 1000 beinhaltet.
  \item Definieren Sie die Sequenz \verb|seq-b|, die alle Quadratzahlen zwischen 0 bis 1000 beinhaltet.
  \item Definieren Sie die Sequenz \verb|seq-c|, die alle Zahlen von 0 bis 1000 beinhaltet, die nicht durch 3 teilbar sind.
  \item Definieren Sie die Sequenz \verb|seq-d|, die alle Tupel [n, m] von ganzen Zahlen beinhaltet f\"ur die gilt: $0 < n < 1000 \wedge n^2 < m \wedge \text{m ist minimal}$. Die Sequenz beginnt also mit [1,2], [2,5], [3,10].
  \item Definieren Sie die Sequenz \verb|seq-e|, die alle Zahlen mit genau 5 Ziffern (dargestellt als 5 Tupel), die ein Palindrom sind enth\"alt, es soll au\ss{}erdem gelten, dass die Ziffern bis zur mittleren Zahl strikt aufsteigend sind. [0 2 3 2 0] ist also Teil der Sequenz, aber nicht [0 3 2 3 0] oder [1 1 1 1 1].
%  (defn palin []
%  (for [a (range 0 10) b (range 0 10) c (range 0 10) :when (< a b c)]
%    [a b c b a]))
  
    
  \end{enumerate}
\end{exercise}

\begin{exercise}[Fibonacci]
Die Folge der Fibonacci Zahlen beginnt mit $F_0=0$ und $F_1=1$. Jedes weitere Folgenglied ist die Summe der beiden vorangehenden Glieder: $F_{n}=F_{n-1}+F_{n-2}$ 
\begin{enumerate}[label=\alph*)]
  \item Schreiben Sie eine Funktion \verb|fibonacci|, die eine ganze  Zahl $z$ als Eingabe bekommt und eine Sequenz mit den ersten $z$ Fibbonaccizahlen erzeugt.
  \item Testen Sie Ihre Funktion auch einmal mit 100.
  \end{enumerate}
\end{exercise}






\begin{exercise}[Duplikate entfernen]
Gegeben sei ein Vektor $v$, der Duplikate enthalten kann. Schreiben Sie eine Funktion \texttt{remove-duplicates}, die alle Duplikate aus dem Vektor entfernt, dabei aber die Reihenfolge der Elemente nicht modifiziert. 

Die Funktion soll beispielsweise so aufgerufen werden:
\begin{verbatim}
user=> (remove-duplicates [])
()
user=> (remove-duplicates nil)
()
user=> (remove-duplicates [1 2 1])
(1 2)
user=> (remove-duplicates [1 2 3 "dd" 2 :a 3])
(1 2 3 "dd" :a)
\end{verbatim}

Es ist nur wichtig, dass das Ergebnis eine sequentielle Kollektion ist. Der genaue Datentyp ist irrelevant.
\end{exercise}


\section*{Fragen}
Bei Fragen wenden Sie sich bitte an Philipp K"orner (\texttt{p.koerner@hhu.de}).
\end{document}

