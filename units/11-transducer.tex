\documentclass[11pt,a4paper]{article}

\usepackage[ngerman]{babel}
\usepackage[TS1,T1]{fontenc}
\usepackage[utf8x]{inputenc}
\usepackage{theorem}
\usepackage[scaled=0.9]{helvet}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[T1]{fontenc}
\usepackage{hyperref}
\usepackage{stmaryrd}
\usepackage{pgf,tikz}
\usepackage{relsize}
\usepackage{enumitem}
\usepackage{mathtools}
\usepackage{graphicx}
\usepackage{algpseudocode,amsmath,xifthen}

\newcounter{numb}
\theoremstyle{break}
\theorembodyfont{\upshape}
   	\newtheorem{aufgabe}{Aufgabe}[numb]
\setcounter{numb}{11}
\setlength{\oddsidemargin}{0cm}
\setlength{\textwidth}{16cm}
\setlength{\textheight}{23cm}
\setlength{\topmargin}{-2cm}

\usetikzlibrary{shapes,arrows,automata,positioning,decorations.fractals}
\renewcommand\familydefault{\sfdefault}


\begin{document}

\begin{minipage}[b]{\textwidth}
\parbox[t]{5cm}{%
\includegraphics[width=4cm]{unilogo}
\hfill
}
\parbox[b]{11cm}{%
%\scshape%
Heinrich-Heine-Universit\"at D\"usseldorf\\
Institut f\"ur Informatik\\
Lehrstuhl Softwaretechnik und Programmiersprachen\\
%Professor Dr.\ M.\ Leuschel
Philipp K\"orner
}

%%date
%\hfill 1.\@ August 2017\rule{0mm}{6mm}\quad\ %% <--
\end{minipage}
\begin{center}
\bf
Funktionale Programmierung -- WS 2020 / 2021\\
Reading Guide 11: Transducer
\end{center}

\pagestyle{empty}

\paragraph{Zeitliche Orientierung:} Diese Lerneinheit sollte bis zum 11.02.2021 abgeschlossen werden.
%\paragraph{Abgabe des Lerntagebuchs} \"uber das ILIAS bis zum 16.5.2020 mit unbegrenzt Material, Nachfrist bis zum 23.5.2020 mit zwei Seiten A4.

\section{Material} 

\begin{itemize}
    \item 16\_transducer.clj
    \item Rich Hickey: Transducers \url{https://www.youtube.com/watch?v=6mTbuzafcII}
    \item Rich Hickey: Inside Transducers \url{https://www.youtube.com/watch?v=4KqUvG8HPYo}
\end{itemize}


\section{Lernziele}

Nach dem Bearbeiten dieser Lerneinheit sollten Sie in der Lage sein

\begin{itemize}
    \item den Sinn von Transducern zu beschreiben.
    \item bestehende Transducer zu lesen und korrekt zu verwenden.
    \item selbst einfache (nicht state-behaftete) Transducer zu schreiben.
\end{itemize}

\section{Highlights}

\begin{itemize}
    \item reduce vs. transduce
    \item Durchreichen von Step-Funktionen
    \item State-Flushing
\end{itemize}



\section{Aufgaben}

\begin{aufgabe}[Transducer]

Implementieren Sie eine Funktion \verb|(transplace m)|,
die eine Map \verb|m| als Argument bekommt und einen Transducer zur\"uckgibt.
Wenn ein Element als Schl\"ussel in \verb|m| vorhanden ist,
soll es durch den assoziierten Wert ersetzt werden,
ansonsten soll das originale Element verwendet werden.

Die Funktion \texttt{replace} darf dabei nicht benutzt werden.

\vspace{8px}
Beispielaufrufe:
\begin{verbatim}
user=> (transduce (transplace {:y :a}) conj [:x :y :z])
[:x :a :z]
user=> (transduce (comp (transplace {nil 0}) (map inc))
                  conj
                  [42 nil 3])
[43 1 4]
user=> (transduce (comp (transplace {nil -1}) (partition-by pos?)) 
                  conj
                  [1 2 3 0 5 6])
[[1 2 3] [0] [5 6]]
\end{verbatim} 
\end{aufgabe} 

\begin{aufgabe}[Square-and-Multiply]

Potenzen von nat\"urlichen Zahlen kann man via $b^e = \underbrace{b * b * ... * b}_{e\text{ mal}}$ berechnen.
Multiplikationen zweier Zahlen sind auf der CPU jedoch relativ langsam.

Das Prinzip der bin\"aren Exponentiation ist, dass man Multiplikationen einspart, indem man  zuerst $b^{2^i}$ f\"ur $0 < 2^i \leq e$ berechnet und dann die passenden Terme multipliziert. Diese ergeben sich aus der Bin\"ardarstellung des Exponenten, beispielsweise $27 = 16 + 8 + 2 + 1$.

Folglich wird $30^{27}$ mittels $30^{16} * 30^8 * 30^2 * 30^1 = 30^{2^4} * 30^{2^3} * 30^{2^1} * 30^{2^0}$ berechnet.

In dieser Aufgabe soll dieser Algorithmus implementiert werden. Im Folgenden wird ein m\"oglicher L\"osungsansatz beschrieben:

\begin{enumerate}[label=\alph*)]
\item
  Schreiben Sie eine Funktion \texttt{(defn to-bits [n] ...)}, die eine nat\"urliche Zahl nimmt und eine Liste von 0en und 1en zur\"uckgibt, die eine Repr\"asentation der Bin\"ardarstellung von n ist.
\item 
    Schreiben Sie eine Funktion \texttt{(defn squares [b e] ...)}, die zu einer nat\"urlichen Zahl b die Sequenz \texttt{[$b^{2^0}$ $b^{2^1}$ $b^{2^2}$ ... $b^{2^j}$]} f\"ur $j \coloneqq \max\limits_{k} (2^k \leq e)$  berechnet.
\item
  F\"uhren Sie die beiden vorhergehenden Funktionen in geeigneter Weise zu einer Funktion \texttt{(defn square-and-multiply [b e] ...)} zusammen.
\end{enumerate}
\end{aufgabe}

\begin{aufgabe}[Hamilton-Pfad]
    Ein Hamilton-Pfad ist ein besonderer Pfad durch einen Graphen:
    jeder Knoten im Graphen wird genau einmal besucht.
    Im Folgenden soll eine Variante einer Suche nach einem Hamilton-Pfad implementiert werden.
    Zur Vereinfachung wird angenommen, dass der Startknoten bekannt ist.

    Die Funktion \verb|hamilton| bekommt als erstes Argument
    eine Liste an (gerichteten) Kanten der Form \verb|[start ziel]|,
    als zweites Argument die Liste der Knoten im Graphen
    und als drittes Argument den Knoten, von dem aus die Suche
    nach einem Hamilton-Pfad beginnen soll.
    Beispielsweise sollen Aufrufe wie folgt aussehen:

    \begin{verbatim}
    user=> (hamilton [[:a :b] [:b :c] [:c :d]]
                     #{:a :b :c} 
                     :a)
    (:a :b :c)
    user=> (hamilton [[:a :a] [:a :b] [:b :c] [:c :d]] 
                     #{:a :b :c}
                     :a) 
    (:a :b :c) ;; mit Selbstkante an :a
    user=> (hamilton (shuffle [[:a :a] [:a :d] [:b :c] [:a :b] [:c :d]])
                     #{:a :b :c :d} 
                     :a)
    (:a :b :c :d)
    user=> (hamilton [[:a :a] [:a :d] [:b :c] [:a :b] [:c :d]]
                     #{:a :b :c :d} 
                     :b)
    nil ;; kein Pfad
    \end{verbatim}

    Implementieren Sie die Funktion \verb|hamilton|.
    Z\"ahlen Sie dabei nicht naiv alle Permutationen der Knoten auf.
\end{aufgabe}

\section*{Fragen}
Bei Fragen wenden Sie sich bitte an Philipp K"orner (\texttt{p.koerner@hhu.de}).
\end{document}

